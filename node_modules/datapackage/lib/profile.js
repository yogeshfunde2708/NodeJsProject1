'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var tv4 = require('tv4');
var axios = require('axios');
var isString = require('lodash/isString');

var _require = require('./errors'),
    DataPackageError = _require.DataPackageError;

var helpers = require('./helpers');

// Module API

/**
 * Profile representation
 */

var Profile = function () {
  _createClass(Profile, [{
    key: 'validate',


    /**
     * Validate a data package `descriptor` against the profile.
     *
     * @param {Object} descriptor - retrieved and dereferenced data package descriptor
     * @returns {Object} returns a `{valid, errors}` object
     */
    value: function validate(descriptor) {
      var errors = [];

      // Basic validation
      var validation = tv4.validateMultiple(descriptor, this._jsonschema);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var validationError = _step.value;

          errors.push(new Error('Descriptor validation error:\n        ' + validationError.message + '\n        at "' + validationError.dataPath + '" in descriptor and\n        at "' + validationError.schemaPath + '" in profile'));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return {
        valid: !errors.length,
        errors: errors
      };
    }

    // Private

  }, {
    key: 'name',


    /**
     * Name
     *
     * @returns {string}
     */
    get: function get() {
      if (!this._jsonschema.title) return null;
      return this._jsonschema.title.replace(' ', '-').toLowerCase();
    }

    /**
     * JsonSchema
     *
     * @returns {Object}
     */

  }, {
    key: 'jsonschema',
    get: function get() {
      return this._jsonschema;
    }
  }], [{
    key: 'load',

    // Public

    /**
     * Factory method to instantiate `Profile` class.
     *
     * This method is async and it should be used with await keyword or as a `Promise`.
     *
     * @param {string} profile - profile name in registry or URL to JSON Schema
     * @throws {DataPackageError} raises error if something goes wrong
     * @returns {Profile} returns profile class instance
     */
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(profile) {
        var jsonschema, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(isString(profile) && helpers.isRemotePath(profile))) {
                  _context.next = 15;
                  break;
                }

                jsonschema = _cache[profile];

                if (jsonschema) {
                  _context.next = 14;
                  break;
                }

                _context.prev = 3;
                _context.next = 6;
                return axios.get(profile);

              case 6:
                response = _context.sent;

                jsonschema = response.data;
                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context['catch'](3);
                throw new DataPackageError('Can not retrieve remote profile "' + profile + '"');

              case 13:
                _cache[profile] = jsonschema;

              case 14:
                profile = jsonschema;

              case 15:
                return _context.abrupt('return', new Profile(profile));

              case 16:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 10]]);
      }));

      function load(_x) {
        return _ref.apply(this, arguments);
      }

      return load;
    }()
  }]);

  function Profile(profile) {
    _classCallCheck(this, Profile);

    // Registry
    if (isString(profile)) {
      try {
        profile = require('./profiles/' + profile + '.json');
      } catch (error) {
        throw new DataPackageError('Profiles registry hasn\'t profile "' + profile + '"');
      }
    }

    this._jsonschema = profile;
  }

  return Profile;
}();

// Internal

var _cache = {};

// System

module.exports = {
  Profile: Profile
};